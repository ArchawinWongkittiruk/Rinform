/**
 * generated by Xtext 2.24.0
 */
package uk.ac.kcl.mde.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import java.util.HashSet;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import uk.ac.kcl.mde.rinform.DirectionStatement;
import uk.ac.kcl.mde.rinform.ReverseInformProgram;
import uk.ac.kcl.mde.rinform.RinformPackage;
import uk.ac.kcl.mde.rinform.RoomDeclaration;
import uk.ac.kcl.mde.rinform.SentencePart;
import uk.ac.kcl.mde.validation.AbstractRinformValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class RinformValidator extends AbstractRinformValidator {
  public static final String UNREACHABLE_ROOM = "UnreachableRoom";
  
  public static final String NON_CAPITAL_NAME = "NonCapitalName";
  
  @Check
  public void checkRoomNameStartsWithCapital(final RoomDeclaration room) {
    boolean _isUpperCase = Character.isUpperCase(room.getName().charAt(0));
    boolean _not = (!_isUpperCase);
    if (_not) {
      this.warning("Name should start with a capital", 
        RinformPackage.Literals.ROOM_DECLARATION__NAME, 
        RinformValidator.NON_CAPITAL_NAME);
    }
  }
  
  @Check
  public void checkAllRoomsAreReachable(final ReverseInformProgram program) {
    HashSet<DirectionStatement> directions = new HashSet<DirectionStatement>();
    EList<SentencePart> _sentences = program.getSentences();
    for (final SentencePart s : _sentences) {
      if ((s instanceof DirectionStatement)) {
        directions.add(((DirectionStatement)s));
      }
    }
    Set<RoomDeclaration> roomDeclarations = IteratorExtensions.<RoomDeclaration>toSet(Iterators.<RoomDeclaration>filter(program.eAllContents(), RoomDeclaration.class));
    final HashSet<RoomDeclaration> reachedRooms = new HashSet<RoomDeclaration>();
    final Set<RoomDeclaration> _converted_roomDeclarations = (Set<RoomDeclaration>)roomDeclarations;
    RoomDeclaration firstRoom = ((RoomDeclaration[])Conversions.unwrapArray(_converted_roomDeclarations, RoomDeclaration.class))[0];
    reachedRooms.add(firstRoom);
    HashSet<DirectionStatement> _hashSet = new HashSet<DirectionStatement>();
    this.getReachableRooms(firstRoom, reachedRooms, directions, _hashSet);
    int _size = reachedRooms.size();
    int _size_1 = roomDeclarations.size();
    boolean _notEquals = (_size != _size_1);
    if (_notEquals) {
      for (final RoomDeclaration stmt : roomDeclarations) {
        boolean _contains = reachedRooms.contains(stmt);
        boolean _not = (!_contains);
        if (_not) {
          this.warning("This room is unreachable", stmt, 
            RinformPackage.Literals.ROOM_DECLARATION__NAME, RinformValidator.UNREACHABLE_ROOM);
        }
      }
    }
  }
  
  public void getReachableRooms(final RoomDeclaration room, final HashSet<RoomDeclaration> reachedRooms, final HashSet<DirectionStatement> directions, final HashSet<DirectionStatement> usedDirections) {
    for (final DirectionStatement stmt : directions) {
      boolean _contains = usedDirections.contains(stmt);
      boolean _not = (!_contains);
      if (_not) {
        if ((Objects.equal(stmt.getRoom1(), room) && (!reachedRooms.contains(stmt.getRoom2())))) {
          reachedRooms.add(stmt.getRoom2());
          usedDirections.add(stmt);
          this.getReachableRooms(stmt.getRoom2(), reachedRooms, directions, usedDirections);
        } else {
          if ((Objects.equal(stmt.getRoom2(), room) && (!reachedRooms.contains(stmt.getRoom1())))) {
            reachedRooms.add(stmt.getRoom1());
            usedDirections.add(stmt);
            this.getReachableRooms(stmt.getRoom1(), reachedRooms, directions, usedDirections);
          }
        }
      }
    }
  }
}

/*
 * generated by Xtext 2.24.0
 */
package uk.ac.kcl.mde.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import uk.ac.kcl.mde.rinform.ReverseInformProgram
import uk.ac.kcl.mde.rinform.RoomDeclaration
import uk.ac.kcl.mde.rinform.RoomDescription
import uk.ac.kcl.mde.rinform.ItemDeclaration
import java.util.List
import java.util.ArrayList
import uk.ac.kcl.mde.rinform.ItemDescription
import uk.ac.kcl.mde.rinform.DirectionStatement
import uk.ac.kcl.mde.rinform.SentencePart
import uk.ac.kcl.mde.rinform.Direction

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class RinformGenerator extends AbstractGenerator {

	List<RoomDeclaration> declaredRooms = new ArrayList<RoomDeclaration>()
	List<ItemDeclaration> declaredItems = new ArrayList<ItemDeclaration>()

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as ReverseInformProgram
		fsa.generateFile(resource.getFileName, model.getGeneratedCode)
		
	}
	def getFileName(Resource resource) {
		resource.URI.appendFileExtension('txt').lastSegment
	}
	
	def String getGeneratedCode(ReverseInformProgram m){
		'''
		«m.sentences.filter(RoomDescription).map[generateInformCode].join('\n')»
		«m.sentences.filter(RoomDeclaration).map[generateInformCode].join('\n')»
		«m.sentences.filter(ItemDescription).map[generateInformCode].join('\n')»
		«m.sentences.filter(ItemDeclaration).map[generateInformCode].join('\n')»
		«m.sentences.filter(DirectionStatement).map[generateInformCode].join('\n')»
		'''
	}
	dispatch def generateInformCode(SentencePart stmt){''''''}
	
	dispatch def generateInformCode(RoomDescription stmt){
		declaredRooms.add(stmt.room)
		'''«stmt.room.name.toFirstUpper» is a Room. "«stmt.description.getString.toFirstUpper»"'''	
	}
	dispatch def generateInformCode(RoomDeclaration stmt){
		if (!declaredRooms.contains(stmt)){
			stmt.declareRoom
		}	
	}
	dispatch def generateInformCode(ItemDescription stmt){
		declaredItems.add(stmt.item)
		'''«stmt.item.name.toFirstUpper» is in «stmt.item.room.name.toFirstUpper». "«stmt.description.getString.toFirstUpper»"'''
	}
	dispatch def generateInformCode(ItemDeclaration stmt){
		if(!declaredItems.contains(stmt)){
			'''«stmt.name.toFirstUpper» is in «stmt.room.name.toFirstUpper».'''
		}
		else{
			''''''
		}
	}
	dispatch def generateInformCode(DirectionStatement stmt){
		if(!declaredRooms.contains(stmt.room1)){
			stmt.room1.declareRoom
		}			
		if(!declaredRooms.contains(stmt.room2)){
			stmt.room2.declareRoom
		}
		if( stmt.direction == Direction.BELOW || stmt.direction == Direction.ABOVE){
			'''«stmt.direction» «stmt.room1.name.toFirstUpper» is «stmt.room2.name.toFirstUpper»'''
		}
		else{
			'''«stmt.direction» of «stmt.room1.name.toFirstUpper» is «stmt.room2.name.toFirstUpper»'''
		}		
	}
	def declareRoom(RoomDeclaration stmt){
		declaredRooms.add(stmt)
		'''«stmt.name.toFirstUpper» is a Room. '''
	}
	
	def String getString(List<String> text) {
		var toReturn = ""
		for (String word: text){
			toReturn += word + " "
		}
		toReturn.trim()
	}
}

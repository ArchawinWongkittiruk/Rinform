/*
 * generated by Xtext 2.24.0
 */
package uk.ac.kcl.mde.validation;

import java.util.ArrayList;

import uk.ac.kcl.mde.rinform.DirectionStatement;
import uk.ac.kcl.mde.rinform.ReverseInformProgram;
import org.eclipse.xtext.validation.Check
import uk.ac.kcl.mde.rinform.SentencePart
import uk.ac.kcl.mde.rinform.RoomDeclaration
import java.util.HashSet
import uk.ac.kcl.mde.rinform.RinformPackage

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class RinformValidator extends AbstractRinformValidator {
	
	public static val UNREACHABLE_ROOM = "UnreachableRoom";
	public static val NON_CAPITAL_NAME = "NonCapitalName";

//	@Check
//	public void checkPersonNameStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.getName().charAt(0))) {
//			warning("Name should start with a capital",
//					RinformPackage.Literals.GREETING__NAME,
//					INVALID_NAME);
//		}
//	}
	
	@Check
	def checkRoomNameStartsWithCapital(RoomDeclaration room) {
		if (!Character.isUpperCase(room.getName().charAt(0))) {
			warning("Name should start with a capital",
					RinformPackage.Literals.ROOM_DECLARATION__NAME,
					NON_CAPITAL_NAME);
		}
	}
	
	@Check
	def checkAllRoomsAreReachable(ReverseInformProgram program) {
		var directions = new HashSet<DirectionStatement>();
		for(SentencePart s: program.sentences){
			if(s instanceof DirectionStatement){
				directions.add(s)
			}
		}
		var roomDeclarations = program.eAllContents.filter(RoomDeclaration).toSet
		val reachedRooms = new HashSet<RoomDeclaration>
		var firstRoom = roomDeclarations.get(0)
		reachedRooms.add(firstRoom)
		firstRoom.getReachableRooms(reachedRooms, directions, new HashSet<DirectionStatement>)
		
		if(reachedRooms.size != roomDeclarations.size){
			for(RoomDeclaration stmt: roomDeclarations){
				if(!reachedRooms.contains(stmt)){
					warning('This room is unreachable', stmt, 
						RinformPackage.Literals.ROOM_DECLARATION__NAME, UNREACHABLE_ROOM)
				}
			}
		}
	}
	
	def getReachableRooms(RoomDeclaration room, HashSet<RoomDeclaration> reachedRooms, HashSet<DirectionStatement> directions, HashSet<DirectionStatement> usedDirections){
		for(DirectionStatement stmt: directions){
			if(!usedDirections.contains(stmt)){
				if(stmt.room1 == room && !reachedRooms.contains(stmt.room2)){
					reachedRooms.add(stmt.room2)
					usedDirections.add(stmt)
					stmt.room2.getReachableRooms(reachedRooms, directions, usedDirections)
				}
				else if(stmt.room2 == room && !reachedRooms.contains(stmt.room1)){
					reachedRooms.add(stmt.room1)
					usedDirections.add(stmt)
					stmt.room1.getReachableRooms(reachedRooms, directions, usedDirections)
				}
			}
		}	
	}
}
